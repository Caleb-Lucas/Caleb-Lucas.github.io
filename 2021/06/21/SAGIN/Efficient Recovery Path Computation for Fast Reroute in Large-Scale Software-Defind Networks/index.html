<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="论文引用    论文编号 论文名称     4 P. Gill, N. Jain, and N. Nagappan, “Understanding network failures in data centers: Measurement, analysis, and implications,” ACM SIG- COMM Comput. Commun. Rev., vol. 41, no.">
<meta property="og:type" content="article">
<meta property="og:title" content="在大型网络软件定义网络中使用快速重路由来进行有效的故障恢复路径计算">
<meta property="og:url" content="http://example.com/2021/06/21/SAGIN/Efficient%20Recovery%20Path%20Computation%20for%20Fast%20Reroute%20in%20Large-Scale%20Software-Defind%20Networks/index.html">
<meta property="og:site_name" content="CalebLogin的博客">
<meta property="og:description" content="论文引用    论文编号 论文名称     4 P. Gill, N. Jain, and N. Nagappan, “Understanding network failures in data centers: Measurement, analysis, and implications,” ACM SIG- COMM Comput. Commun. Rev., vol. 41, no.">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/caleblogin/pics/raw/master/sagin/fig5.png">
<meta property="article:published_time" content="2021-06-21T10:08:17.000Z">
<meta property="article:modified_time" content="2021-06-23T11:38:01.795Z">
<meta property="article:author" content="CalebLogin">
<meta property="article:tag" content="SDN">
<meta property="article:tag" content="故障恢复">
<meta property="article:tag" content="大规模网络">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/caleblogin/pics/raw/master/sagin/fig5.png">

<link rel="canonical" href="http://example.com/2021/06/21/SAGIN/Efficient%20Recovery%20Path%20Computation%20for%20Fast%20Reroute%20in%20Large-Scale%20Software-Defind%20Networks/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>在大型网络软件定义网络中使用快速重路由来进行有效的故障恢复路径计算 | CalebLogin的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">CalebLogin的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">CalebLogin's blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/21/SAGIN/Efficient%20Recovery%20Path%20Computation%20for%20Fast%20Reroute%20in%20Large-Scale%20Software-Defind%20Networks/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CalebLogin">
      <meta itemprop="description" content="Talk is cheap, show me the code">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CalebLogin的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          在大型网络软件定义网络中使用快速重路由来进行有效的故障恢复路径计算
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-21 18:08:17" itemprop="dateCreated datePublished" datetime="2021-06-21T18:08:17+08:00">2021-06-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-23 19:38:01" itemprop="dateModified" datetime="2021-06-23T19:38:01+08:00">2021-06-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SAGIN/" itemprop="url" rel="index"><span itemprop="name">SAGIN</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h4 id="论文引用"><a class="markdownIt-Anchor" href="#论文引用"></a> 论文引用</h4>
<table>
<thead>
<tr>
<th>论文编号</th>
<th>论文名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>4</td>
<td>P. Gill, N. Jain, and N. Nagappan, “Understanding network failures in data centers: Measurement, analysis, and implications,” ACM SIG- COMM Comput. Commun. Rev., vol. 41, no. 4, pp. 350–361, Aug. 2011.</td>
</tr>
<tr>
<td>5</td>
<td>A. Markopoulou, G. Iannaccone, S. Bhattacharyya, C.-N. Chuah, Y. Ganjali, C. Diot, and C. Diot, “Characterization of failures in an operational IP backbone network,” IEEE/ACM Trans. Netw., vol. 16, no. 4, pp. 749–762, Aug. 2008</td>
</tr>
<tr>
<td>31</td>
<td>J. Hershberger and S. Suri, “Vickrey prices and shortest paths: What is an edge worth?” in Proc. IEEE FOCS, Oct. 2001, pp. 252–259.</td>
</tr>
<tr>
<td>32</td>
<td>Z. Gotthilf and M. Lewenstein, “Improved algorithms for the k simple shortest paths and the replacement paths problems,” Inf. Process. Lett., vol. 109, no. 7, pp. 352–355, 2009.</td>
</tr>
<tr>
<td>28</td>
<td>A. Jarry, “Fast reroute paths algorithms,” Telecomm. Syst., vol. 52, no. 2, pp. 881–888, 2013.</td>
</tr>
<tr>
<td>35</td>
<td>Topology Zoo. Accessed: Jun. 24, 2019. [Online]. Available: <a target="_blank" rel="noopener" href="http://www.topology-zoo.org">http://www.topology-zoo.org</a></td>
</tr>
<tr>
<td>36</td>
<td>CAIDA. Accessed: Jun. 24, 2019. [Online]. Available: <a target="_blank" rel="noopener" href="http://www.caida.org">http://www.caida.org</a></td>
</tr>
<tr>
<td>46</td>
<td>N. L. van Adrichem, F. Iqbal, and F. A. Kuipers, “Backup rules in software-defined networks,” in Proc. IEEE NFV-SDN, Nov. 2016, pp. 179–185.</td>
</tr>
<tr>
<td>48</td>
<td>D. Kempe, J. Kleinberg, and É. Tardos, “Maximizing the spread of influence through a social network,” in Proc. ACM SIGKDD, 2003, pp. 137–146.</td>
</tr>
<tr>
<td>33</td>
<td>T. Akiba, Y. Iwata, and Y. Yoshida, “Fast exact shortest-path distance queries on large networks by pruned landmark labeling,” in Proc. ACM SIGMOD, 2013, pp. 349–360.</td>
</tr>
<tr>
<td>34</td>
<td>T. Akiba, T. Hayashi, N. Nori, Y. Iwata, and Y. Yoshida, “Efficient top- k shortest-path distance queries on large networks by pruned landmark labeling,” in Proc. AAAI, 2015, pp. 2–8.</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<hr />
<p><s>#### 概述</s><br />
<s>1. 本文提出了一种基于预计算备份路径并受多标签路由“曲背”路由的保护方案，在故障发生之后，不论控制器是否可达，甚至openflow的快速故障转移不起作用的时候，保证了故障检测后的实时的恢复，目的零丢包率。</s><br />
<s>2. 该方法基于OpenState，允许编程人员指定转发规则以状态方式自动适应，从而减少对远程控制器的依赖。</s><br />
<s>3. 即使SDN和Openflow提供了巨大的灵活性和强大的平台编程，但是他们实现故障恢复这些功能不是很容易，因为这些事件必须涉及到中央控制器（事件通知和安装新的转发规则）与不可忽略的延迟和信号开销。</s><br />
<s>4. openflow引入了快速故障转移机制，本地进行故障的反应，不需要与控制器进行商量。这是通过为同一流条目实例化多个操作桶，并根据链接的状态（活动或失败）应用它们来实现的。但是快速故障转移依赖于本地环路机制，前提需要保证替换路径是有效的。当网络拓扑发生改变的时候，环路路径可能是不可用的。</s><br />
<s>5. openstate包括了交换机根据不同状态应用不同的匹配动作规则，并使状态根据状态机演化，在这些状态机中转换是由包级事件触发的。</s><br />
<s>6. 允许重新分配故障影响的流通过绕道任何方便节点的主要路径。没有采用特定的信令程序来触发弯路，而是将相同的数据流量流的数据包标记并转发，以通知节点故障，并诱导状态转换以激活预先计算的弯路。</s><br />
<s>#### openstate</s><br />
<s>1. 首先，openstate将控制逻辑下发到了交换机。控制器不必要处理只需要交换机本地信息的控制任务，这些任务可以下发给交换机。那些需要全局网络信息的任务才需要让控制器来做。</s><br />
<s>2. 在OpenState中，通常的OpenFlow通过具有“流状态”的状态表来进行匹配和操作流表。（1）首先数据包仅使用数据包头的一部分与状态表进行匹配，执行状态查找操作，并向数据包附加状态标签。（2）如果状态表没有匹配任何行，则返回默认状态。然后将数据发送到流表，在那里执行通常的OpenFlow操作。而新的SET_STATE操作可用于插入或重写具有任意值的状态表的行。</s></p>
<h4 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h4>
<ol>
<li>传统的快速重路由算法在大型网络中性能不是很好</li>
<li>我们提出了一种新的算法，利用剪枝搜索快速计算全对交换机/主机在链路故障时的恢复路径。对于需要严格路径鲁棒性水平的应用，我们还扩展了该算法，以快速找到最短的保证代价路径，以确保在路径链路故障时使用的恢复路径具有最小的代价。与传统的解决方案相比，我们的评估显示，我们的算法比实际实现快了大约8 ~ 81倍，比最先进的解决方案快了1.93 ~ 3.11倍。我们的结果还表明最短保证成本路径可以显著降低恢复路径的成本。此外，我们设计了一个原型来展示如何在OpenFlow网络中部署我们的算法。</li>
<li>研究表明，节点和链路故障是相当频繁的和不可预料的，不管是在数据中心还是广域的网络环境中。</li>
<li>测量研究表明，在数据中心和广域网环境[4]，[5]中，链路和节点故障非常频繁和意外。即使像[5]中报告的那样，很重要的一部分故障是短暂的，持续时间只有几秒或几分钟，许多对延迟敏感的应用程序，如VoIP或视频会议[6]，只能容忍50毫秒以下的恢复时间[7]，[8]。在链路/节点故障期间缓慢的收敛可能会导致这些应用程序的严重中断。因此，对此类失败做出快速反应是一项关键任务。</li>
<li>计算和绕过流量从故障路径到恢复路径的过程称为[9]重路由。默认的SDN重路由方案包括以下步骤:1)交换机向控制器上报故障;2)控制器恢复路径的主动计算，3)所涉及的交换机的流表更新。[10]可以显著降低流表更新延迟。然而，路径计算和开关控制器交互仍然需要大量的总恢复时间。有报道称，由于[11]的开销，SDN网络中IGP的恢复时间可能比传统网络慢。</li>
<li>通常，可以在故障事件上响应地计算恢复路径，也可以在故障发生前主动计算恢复路径。由于路由更新延迟，响应式方法可能需要花费大量时间来寻找替代路径。为了尽可能快地重新路由，快速重路由(FRR)被提出作为一种主动恢复路径的预计算机制来启动本地交换表。在传统IP和MPLS网络[12]-[15]中，已经有相当多的努力使用FRR来最小化重路由时间。FRR也被认为很容易在SDN[16] -[19]中部署。在SDN中使用源路由[20]-[22]进行FRR应用的研究也有所进展。然而，正如第II-A节所总结的，传统的恢复路径计算方法在SDN环境中遭受了令人望而却步的性能下降，因为网络规模比传统的FRR场景大得多(通常超过1000个交换机/主机[23]，[24])。同时，据报道，如果故障恢复仅依赖于商业OpenFlow交换机的内置机制，它可能需要高达数百毫秒的[25]。由于SDN对单链路故障非常敏感，[26]需要一个全(100%)覆盖保护方案。因此，提高全对交换机/主机在链路故障时的恢复路径计算效率至关重要。</li>
</ol>
<h4 id="提出的算法概述"><a class="markdownIt-Anchor" href="#提出的算法概述"></a> 提出的算法概述</h4>
<ol>
<li>在本文中，我们关注的是在大规模sdn链路失效时高效FRR恢复路径计算的算法挑战。使用FRR机制，流量会在本地发生绕道，从有故障链路的节点(原始路径上最后一个可到达的节点)到目标节点的恢复路径。选择恢复路径有不同的条件。常用的策略是选择从故障节点到目标节点[27]、[28]代价最小的最短路径，称为最短恢复路径。本工作旨在提供一种快速路径计算方法:1)最短恢复路径和2)最短保证代价路径。对于第一个挑战，我们需要高效地计算图中的最短恢复路径。利用故障节点到目标节点之间的最短路径算法，可以计算出最短恢复路径。Dijkstra是目前运营商级控制器如ONOS[29]和OpenDaylight[30]中使用的默认算法。由于朴素的Dijkstra算法不适用于大规模网络，人们提出了各种各样的方法[31]，[32]来解决最短恢复路径计算的可扩展性。</li>
<li>对于第二个挑战，我们需要一个计算最短保证代价路径的快速算法。保证代价定义为与给定路径相关的最坏情况恢复路径的代价(即路径链路故障时的最大恢复代价)。具有最小保证代价的路径P称为最短保证代价路径。我们使用图1来说明寻找最短保证代价路径的必要性。直观地说，在某些情况下，保证成本的最短路径更可取，因为在最短路径上恢复链路故障可能会导致较高的成本。提出了一种计算全对最短保证代价路径的算法[28]，其复杂度为O(MN+ N2 logN)。然而，它的性能在大规模网络中不够有效。</li>
<li>我们提出了一个高效的两阶段算法，包括索引阶段和查询阶段，利用一般的剪枝搜索[33]，[34]框架和我们自己的剪枝策略索引中间结果来解决第一个难题。我们的算法可以通过降低现有解的索引时间复杂度O(lM + lN(logN + l))和查询时间复杂度O(l)来实现显著的性能改进，其中l，一个由剪枝搜索引入的因子，在大多数现实拓扑中被证明是一个小于300的相当稳定的整数。直观地说，较低的l表示搜索中更高效的修剪策略，这意味着在索引期间修剪更多不必要的中间结果。我们将我们的解决方案与全对节点(100%节点保护)场景中的理论前沿和实际实现(网络系统设计中常用的Dijkstra算法)进行了比较。我们的解决方案的计算时间是8∼81倍的实用解决方案在各种各样的网络规模从153∼163个节点(从Topolopy Zoo[35]和 AS网络[36]),它是1.93∼3.11倍理论最先进的带有754∼5340个全对节点保护场景。从我们的评估结果来看，实际解决方案无法在节点数超过1163的网络中完成评估，而优化后的预计算解决方案可以在几天内完成节点数超过5340的网络的评估。相反，我们的算法可以计算从几分钟到几小时的全对恢复路径。我们的算法还可以在节点保护百分比小于100%的情况下提供更高的效率。此外，我们还实现了一个原型来展示如何在OpenFlow网络中部署我们的算法。评价结果表明，在OpenFlow网络中，快速路由比传统的路由方法要快得多。同时，我们将第一种算法推广到具有相同时间复杂度的最短保证代价路径。我们证明了我们的剪枝策略的正确性，并用实际拓扑[35]，[36]对其进行了评估。我们还比较了最短路径和最短保证代价路径之间的保证代价。结果表明，在真实拓扑中，最短保证代价路径可以显著降低链路失效时的最坏恢复代价。此外，我们还通过考虑多个链接故障和节点故障来扩展我们的讨论。</li>
</ol>
<h4 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h4>
<ul>
<li>替换路径问题/并行最短路径算法:计算最短恢复问题是图论中已深入研究的替换路径问题的一个子问题。在求解替换路径问题时，[31]针对无向图中给定的一对s和t提出了一种O(M + N logN)算法。在有向图中没有比O(MN +N2 log logN)[32]更快的解。显然，由于时间复杂度高，直接将这些算法应用于SDN网络的全对恢复路径计算是不可接受的。<strong>虽然存在有向图中具有线性时间复杂度的并行最短路径算法，如Δ−步进算法[47]，但大多数现有的SDN控制器不能支持多控制器实例的分布式路径计算。例如，ONOS可以支持多个控制器实例，但路径计算仍然在一个实例中执行。</strong></li>
</ul>
<h4 id="设计原理"><a class="markdownIt-Anchor" href="#设计原理"></a> 设计原理</h4>
<ol>
<li>我们的FRR机制通过将计算分为两个阶段来减少恢复路径的计算:索引阶段和查询阶段。不同于传统的方法直接计算最终的最佳路径(全对短期est恢复最短路径或保成本路径),我们只计算中间结果用一个优化算法在索引阶段,然后通过使用查询阶段的中间结果计算出最终路径。此外，我们在优化算法中提出了一种策略，可以显著减少索引阶段不必要的中间结果。这样可以大大减少计算时间，即全对最短恢复路径的索引时间(索引阶段所用时间)和查询时间(查询阶段所用时间)之和。</li>
<li>为了激励我们的设计，我们使用图2显示了一个路径恢复链路故障的案例。在本例中，为了保护从s到t的路径，部署了不同的恢复方案。图2(a)为SDN中传统的主动故障恢复方案。当链路出现故障时，交换机首先向控制器发送恢复请求，控制器计算出一条新的路径，并在交换机中插入转发规则。我们的实验表明，对于一个1163个节点的网络，利用Dijkstra算法，一个最短恢复路径的计算时间需要195ms。</li>
<li>图2(b)是SDN[27]中传统的快速重路由算法。控制器在故障发生前计算出恢复路径，并在需要保护的交换机(s、h、a、d)中插入转发规则。当发生故障时，如h→a、i→a故障，交换机本地发生h→g、i→j重路由。对于1163节点的网络，当时间复杂度k = N时，所有交换机到t的保护路径需要227.231s。</li>
<li>我们还利用一种主动的方法在故障发生之前预计算恢复路径。但是，我们的方法不直接计算恢复路径。如图2©所示，控制器在索引阶段计算中间结果为索引，在查询阶段根据索引查询受保护交换机的恢复路径。当发生故障时，受保护的交换机可以将流重定向到恢复路径，而无需控制器干预。如果拓扑结构发生变化，即多个交换机/链路添加/删除/故障，我们的方法可以快速重新计算索引和恢复路径。对于一个1163个节点的网络，索引只需要0.144s，计算到t的所有交换机的恢复路径只需要2.785s。</li>
<li>我们的设计利用的关键直觉是，我们可以通过预计算中间索引结果来加速恢复路径的设置。为此，我们将计算分为两个阶段:索引阶段和查询阶段。设计中的另一个关注点是存储索引时的空间开销。一种简单的方法是计算所有最终恢复路径并将它们存储在索引中。查询可以在O(1)的时间内完成(在计算完成后直接访问内存中的计算结果)。然而，索引的大小对于大型网络是不可接受的。在2跳覆盖策略[48]的驱动下，我们设计了一种剪枝搜索算法，通过平衡索引时间和查询时间来减少索引大小。我们的方法通过删除索引过程中不必要的结果，可以显著减少索引的大小。在查询恢复路径时，折衷方法是略微增加计算时间。直观地说，我们的方法迭代计算索引，并删除每次迭代后从不使用的中间结果。最后的路径结果可以在修剪后的索引上计算。例如，图3的例子显示了朴素方法和我们的方法在索引大小上的差异。</li>
</ol>
<h4 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h4>
<h5 id="概括"><a class="markdownIt-Anchor" href="#概括"></a> 概括</h5>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mo>=</mo><mo stretchy="false">(</mo><mi>V</mi><mo separator="true">,</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G=(V,E) 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span></span></p>
<h5 id="问题定义"><a class="markdownIt-Anchor" href="#问题定义"></a> 问题定义</h5>
<ul>
<li>简单地说，特定路径P(s, t)的恢复路径R(P(s, t))是另一条从s到t的路径，它不经过P(s, t)的第一条边。这条路径用于在原始路径的第一条链路失效时，将网络数据包从s重路由到t。正如我们上面提到的，使用FRR机制，重路由发生在交换机本地。换句话说，当交换机发生链路故障时，交换机在本地选择到目的端的恢复路径，以绕过从交换机到目的端的原始路径中的第一条失效链路。</li>
<li>问题1寻求计算图G中任意一对节点之间的任何路径的最短恢复路径。</li>
<li>对于问题2，我们首先定义保证代价η(P(s, t))为最坏情况恢复场景中实际路径P(s, t)之后的数据包的代价。因为P(s, t)在不同的链路故障场景下会导致不同的恢复成本，所以有一个故障场景会导致最大的恢复成本，比如η(P(s, t))。如前所述，保证代价最短的路径Gp(s, t)是从s到t的保证代价最小的路径。</li>
<li>定义两个问题：
<ul>
<li>计算路径(s,t)的最短恢复路径：对于给定的路径(s,t)之间的任意一对节点，返回节点s到节点t的最短路径。</li>
<li>计算代价最短路径：有这样一条路径，节点s到节点t之间有最小的保证代价。</li>
</ul>
</li>
</ul>
<h4 id="最短恢复路径"><a class="markdownIt-Anchor" href="#最短恢复路径"></a> 最短恢复路径</h4>
<ul>
<li>正如我们上面提到的，我们的算法通过减少不必要的计算量来提高效率。我们将计算分为两个阶段:索引阶段和查询阶段;我们证明了索引阶段可以避免大部分不必要的计算任务。</li>
<li>在本节中，我们将首先描述查询阶段的算法:如何利用索引中间结果的知识查询最短的恢复路径。然后，我们将在索引阶段描述算法，这是我们提出的核心贡献:如何索引中间结果，并通过剪枝策略(或剪枝搜索)减少不必要的结果。</li>
</ul>
<h5 id="2-hop-cover查询最短恢复路径"><a class="markdownIt-Anchor" href="#2-hop-cover查询最短恢复路径"></a> 2-hop cover查询最短恢复路径</h5>
<ul>
<li>首先介绍了如何利用2跳覆盖[48]来查询最短恢复路径。直观地说，2-hop覆盖提供了通过结合两个简单路径计算(如最短路径)的结果来计算复杂路径(带有一些边/节点约束)的能力。我们在表II中给出了约束路径的符号。假设V中的每个节点都被分配了一个整数形式的节点ID。因此我们能够比较两个节点通过比较节点ID的形式。</li>
<li>分离恢复路径P(s,t)为两部分，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>P</mi><mrow><mo>=</mo><mi>x</mi><mo separator="true">,</mo><mo>=</mo><mi>y</mi></mrow><mrow><mo>&gt;</mo><mi>u</mi></mrow></msubsup><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P^{&gt;u}_{=x,=y}(u,v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.133108em;vertical-align:-0.383108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.74037em;"><span style="top:-2.4530000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mrel mtight">=</span><span class="mord mathdefault mtight">x</span><span class="mpunct mtight">,</span><span class="mrel mtight">=</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mrel mtight">&gt;</span><span class="mord mathdefault mtight">u</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.383108em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span>表示路径必须以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>e</mi><mrow><mi>u</mi><mo separator="true">,</mo><mi>x</mi></mrow></msub></mrow><annotation encoding="application/x-tex">e_{u,x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">u</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>开始，以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>e</mi><mrow><mi>y</mi><mo separator="true">,</mo><mi>v</mi></mrow></msub></mrow><annotation encoding="application/x-tex">e_{y,v}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>结束。</li>
<li>定义最短恢复路径的代价：</li>
</ul>
<h5 id="用剪枝策略索引中间结果"><a class="markdownIt-Anchor" href="#用剪枝策略索引中间结果"></a> 用剪枝策略索引中间结果：</h5>
<ul>
<li>使用QUERY来计算最短恢复路径在已经计算过的路径上。用根u初始化队列，如果没有找到新的路径，BFS将停止。此外，我们在BFS算法中增加了一个扩展约束，以保证每个扩展节点都大于u，但直接计算<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>P</mi><mrow><mo>&gt;</mo><mi>u</mi></mrow></msup><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P^{&gt;u}(u, v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.74037em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mrel mtight">&gt;</span><span class="mord mathdefault mtight">u</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span>是一种蛮力方法，这导致了大量的空间和时间。基于对最短路径和第k条最短路径[33]，[34]的精简搜索，我们认为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>P</mi><mrow><mo>&gt;</mo><mi>u</mi></mrow></msup><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P^{&gt;u}(u, v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.74037em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mrel mtight">&gt;</span><span class="mord mathdefault mtight">u</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span>中的大多数路径都不需要计算最短恢复路径。</li>
<li>因此，在计算<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>P</mi><mrow><mo>&gt;</mo><mi>u</mi></mrow></msup><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P^{&gt;u}(u, v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.74037em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mrel mtight">&gt;</span><span class="mord mathdefault mtight">u</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span>时使用剪枝策略来剪枝不必要的结果和减少索引时间是必要的。这个框架被称为剪枝搜索<br />
<img src="https://gitee.com/caleblogin/pics/raw/master/sagin/fig5.png" alt="fig5" /></li>
</ul>
<ol>
<li>场景A</li>
<li>场景B</li>
<li>场景C<br />
场景CD：如果w→t在s→w相交，则不需要其他路径</li>
<li>场景D<br />
可以保证当w→t在s→w相交时，可以找到一条比s→w→t短的恢复路径。</li>
</ol>
<ul>
<li>命题1</li>
</ul>
<h4 id="最短保证代价路径计算"><a class="markdownIt-Anchor" href="#最短保证代价路径计算"></a> 最短保证代价路径计算</h4>
<h4 id="评估"><a class="markdownIt-Anchor" href="#评估"></a> 评估</h4>
<ul>
<li>本节分为两部分。第一部分评估我们的算法在各种数据集上的性能。在第二部分中，我们用Mininet和Open vSwitch (OvS)实现了一个原型，以展示我们的解决方案和传统方法之间的链路恢复时间的差异。</li>
</ul>
<ol>
<li>环境。</li>
</ol>
<ul>
<li>我们首先在使用Intel i7-6700@4GHz和32GB DDR4内存的Linux服务器上进行实验，评估我们的算法。我们使用c<ins>来实现我们的算法，并让它在GitHub的仓库[50]上公开可用。由于编译器优化的效率可能会根据不同的cpu而有所不同，我们决定不打开g</ins>中的编译器优化选项，以便进行公平的比较。因此，我们使用g++进行编译而无需任何优化。我们使用2字节整数(UNSIGNED SHORT)来表示节点ID和代价。我们通过测量100万个随机查询来评估平均查询时间。</li>
<li>数据集:为了确认我们的方法足够健壮和可扩展，我们在各种现实网络[35]，[36]上评估了我们的算法:三种来自运营商主干网，七种来自AS网络。虽然TOPO8和TOPO9有超过20,000个节点，这在SDN中并不常见，但我们仍然使用这些拓扑来测试我们算法的可伸缩性。我们把所有的拓扑都看成无向图。由于原始拓扑没有代价信息，我们通过gamma分布(从测量结果[51])分配每个边的代价，α =0.2463，λ =55.9280，代价的尺度范围从1到524。我们在表III中给出了这些网络的参数。</li>
<li>由于节点的度会影响l，而l与我们算法的性能有关，所以我们度量网络的度分布。这些网络遵循幂律分布(80-20规则)，这意味着超过80%的顶点角度小于2。同时，我们度量了路径代价在全对节点上的分布。我们发现80%到90%的成本低于100。</li>
</ul>
<ol start="2">
<li>计算最短恢复路径的性能</li>
</ol>
<ul>
<li>首先，我们在TABLE IV中展示了在这些真实世界拓扑上计算最短恢复路径的性能。IT表示索引时间;MS表示内存大小，表示存储L和拓扑的内存使用情况;QT表示平均查询时间。CT表示计算时间，由索引时间和查询时间组成。我们还对两种现有方法的性能进行了评价。一个是优化的预计算[28]，另一个是朴素的Dijkstra[27]。后者是直接查询最短恢复路径(R(P(s, t)))的算法。我们还使用c<ins>和g</ins>实现了这些算法。因为预先计算优化算法必须计算所有成对最短恢复路径来得到正确的结果,优化计算后的CT表示全对s和t的恢复路径计算时间，朴素Dijkstra算法的CT表示查询图中所有对节点最短恢复路径的时间。SR表示加速比，它是将优化预计算或朴素Dijkstra的计算时间除以我们算法的计算时间计算出来的。我们通过索引时间和查询次数乘以需要保护的节点数来估算TOPO8、TOPO9的CT，因为全对保护的计算时间超过半小时，而保护20k以上的节点在现实中并不常见。‘NA’表示朴素的Dijkstra和优化的预计算不能在半小时内完成计算。</li>
<li>1)索引时间和计算时间:从表4中我们可以看到索引时间(算法2)非常小，说明算法比其他算法更具有可扩展性。虽然优化后的预计算算法降低了朴素Dijkstra算法的时间复杂度，但剪枝搜索算法的计算时间远远小于其他算法。我们的算法计算时间比TOPO1、TOPO2和TOPO3优化后的预计算时间要长，而且这些拓扑都是小拓扑。作为开销，TOPO1和TOPO2的索引时间开销最大。2）查询时间:如前所述，查询时间依赖于l。查询算法可以在微秒级查询结果，因为所有的l都小于103，最长的QT是83 μs。虽然优化的预计算算法没有利用查询中的任何时间，但计算时间太长，无法抵消其优点。此外，我们的实验表明，查询时间并不会随着网络规模的增加而迅速增加。3)内存大小:我们的算法受益于2跳覆盖策略，使用内存空间来存储中间结果。我们可以看到TOPO3 (817 MB)的内存使用比TOPO2和TOPO4大，因为我们有更大的l(86)。观察到TOPO3中有许多线性拓扑子图，使l变大，证明了这一结果。我们认为当前的商用服务器内存一般都在32GB以上，内存的使用已经足够了。同时随着现代存储技术的快速发展，应该容易满足存储空间的要求。然而，为了进一步提高可伸缩性，我们仍然需要减少内存大小，这将在今后的工作中进行研究。</li>
</ul>
<ol start="3">
<li>分析</li>
</ol>
<ul>
<li>修剪搜索:图7 (a)显示的数量的累积分布路径添加到L .从图7 (a)我们可以看到,在调用索引1000次之前大多数路径添加到L(第二行算法2),这意味着调用1000次索引后大多数的计算恢复路径是不必要的。</li>
<li>L的大小:图7(b)显示了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><mi>L</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|L(v)|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault">L</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mord">∣</span></span></span></span>在大小上的分布。由图7(b)可以看出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∀</mi><mi>v</mi><mo>∈</mo><mi>V</mi><mo separator="true">,</mo><mi mathvariant="normal">∣</mi><mi>L</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">∀v∈V,|L(v)|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord">∀</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∣</span><span class="mord mathdefault">L</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mord">∣</span></span></span></span>在所有查询时间中差别不大，比较稳定。</li>
</ul>
<ol start="4">
<li>计算最短保证代价路径的性能</li>
</ol>
<ul>
<li>利用全对最短恢复路径的知识，给出了在一些大规模拓扑(TOPO6、TOPO7、TOPO8、TOPO9和TOPO10)下的性能和特性评估结果。大规模拓扑可以提供更多的路径来分析最短保证代价路径的特性。我们在表V中给出了最大QT(大部分QT非常小，因为r很小)。</li>
<li>如前面所述，r是R(v)的平均大小，与l和L(v)的定义相似，表示修剪策略的效率。在我们的评估中,我们发现r是1,因为这些网络中的大多数节点没有另一种恢复路径到达其他节点(例如,大部分节点的度是1)。例如,一个节点只有一条边意味着它无法找到另一条路,如果仅有的一条边失败了。因此，这些节点的|R|不大于1。另一方面，如果网络中有大量节点有大量的度可用，那么IT将会较小。其原因是，在剪枝搜索[33]中，度较大的节点(大多数路径必须经过这些中心顶点)可以显著增加剪枝的概率。</li>
</ul>
<ol start="5">
<li>最短保证代价路径的特征</li>
</ol>
<ul>
<li>以TOPO7和TOPO10为例，分析了最短保证成本路径的特征。通过比较最短路径的路径代价、最短保证代价路径、最短路径的最大恢复路径和最短保证代价路径的最大恢复路径，评价最短保证代价路径的特性。</li>
<li>我们将主路径定义为数据包默认经过的路径。从图8(a)(b)可以看出，选择最短的保证成本路径作为主路径可以显著降低恢复路径的最大成本。在图8(a)中，当我们选择最短的保证成本路径作为主路径时，所有恢复路径都小于300。同时，80%的恢复路径小于100，如果选择最短路径作为主路径，这一比例大于60%。同时，从图8(b)中可以看出，恢复路径的最大开销从400减少到250，减少了150，而主路径的开销只增加了50，从100增加到150。显然，最短保证成本路径可以显著降低恢复路径的成本。</li>
</ul>
<ol start="6">
<li>原型的实现与评估</li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/SDN/" rel="tag"># SDN</a>
              <a href="/tags/%E6%95%85%E9%9A%9C%E6%81%A2%E5%A4%8D/" rel="tag"># 故障恢复</a>
              <a href="/tags/%E5%A4%A7%E8%A7%84%E6%A8%A1%E7%BD%91%E7%BB%9C/" rel="tag"># 大规模网络</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/06/21/SAGIN/Link%20Failure%20Recovery%20Mechanism%20in%20Software%20Defined%20Networks/" rel="prev" title="Link Failure Recovery Mechanism in Software Defined Networks">
      <i class="fa fa-chevron-left"></i> Link Failure Recovery Mechanism in Software Defined Networks
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BA%E6%96%87%E5%BC%95%E7%94%A8"><span class="nav-number">1.</span> <span class="nav-text"> 论文引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">2.</span> <span class="nav-text"> 概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%90%E5%87%BA%E7%9A%84%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0"><span class="nav-number">3.</span> <span class="nav-text"> 提出的算法概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%83%8C%E6%99%AF"><span class="nav-number">4.</span> <span class="nav-text"> 背景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86"><span class="nav-number">5.</span> <span class="nav-text"> 设计原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E9%99%88%E8%BF%B0"><span class="nav-number">6.</span> <span class="nav-text"> 问题陈述</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A6%82%E6%8B%AC"><span class="nav-number">6.1.</span> <span class="nav-text"> 概括</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E5%AE%9A%E4%B9%89"><span class="nav-number">6.2.</span> <span class="nav-text"> 问题定义</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E7%9F%AD%E6%81%A2%E5%A4%8D%E8%B7%AF%E5%BE%84"><span class="nav-number">7.</span> <span class="nav-text"> 最短恢复路径</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-hop-cover%E6%9F%A5%E8%AF%A2%E6%9C%80%E7%9F%AD%E6%81%A2%E5%A4%8D%E8%B7%AF%E5%BE%84"><span class="nav-number">7.1.</span> <span class="nav-text"> 2-hop cover查询最短恢复路径</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%94%A8%E5%89%AA%E6%9E%9D%E7%AD%96%E7%95%A5%E7%B4%A2%E5%BC%95%E4%B8%AD%E9%97%B4%E7%BB%93%E6%9E%9C"><span class="nav-number">7.2.</span> <span class="nav-text"> 用剪枝策略索引中间结果：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E7%9F%AD%E4%BF%9D%E8%AF%81%E4%BB%A3%E4%BB%B7%E8%B7%AF%E5%BE%84%E8%AE%A1%E7%AE%97"><span class="nav-number">8.</span> <span class="nav-text"> 最短保证代价路径计算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%84%E4%BC%B0"><span class="nav-number">9.</span> <span class="nav-text"> 评估</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">CalebLogin</p>
  <div class="site-description" itemprop="description">Talk is cheap, show me the code</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">5</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CalebLogin</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
